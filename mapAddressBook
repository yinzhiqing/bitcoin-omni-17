Binary file src/omnicore/.rpc.cpp.swp matches
src/omnicore/rpc.cpp:722:            LOCK(pwallet->cs_wallet);
src/omnicore/rpc.cpp:921:    LOCK(pwallet->cs_wallet);
src/omnicore/rpc.cpp:923:    for (std::map<CTxDestination, CAddressBookData> item : pwallet->mapAddressBook) {
src/omnicore/wallettxbuilder.cpp:140:    // NOTE: require: LOCK2(cs_main, pwallet->cs_wallet);
src/omnicore/wallettxbuilder.cpp:144:    pwallet->AvailableCoins(vCoins, false, nullptr, true);
src/omnicore/wallettxbuilder.cpp:157:        pwallet->LockCoin(outpointLocked);
src/omnicore/wallettxbuilder.cpp:171:    // NOTE: require: LOCK2(cs_main, pwallet->cs_wallet);
src/omnicore/wallettxbuilder.cpp:174:        pwallet->UnlockCoin(output);
src/wallet/init.cpp:244:        pwallet->postInitProcess();
src/wallet/init.cpp:254:        pwallet->Flush(false);
src/wallet/init.cpp:261:        pwallet->Flush(true);
src/wallet/walletdb.cpp:251:             CWalletScanState &wss, std::string& strType, std::string& strErr) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)
src/wallet/walletdb.cpp:262:            ssValue >> pwallet->mapAddressBook[DecodeDestination(strAddress)].name;
src/wallet/walletdb.cpp:268:            ssValue >> pwallet->mapAddressBook[DecodeDestination(strAddress)].purpose;
src/wallet/walletdb.cpp:303:            pwallet->LoadToWallet(wtx);
src/wallet/walletdb.cpp:311:            if (nNumber > pwallet->nAccountingEntryNumber) {
src/wallet/walletdb.cpp:312:                pwallet->nAccountingEntryNumber = nNumber;
src/wallet/walletdb.cpp:331:                pwallet->LoadWatchOnly(script);
src/wallet/walletdb.cpp:391:            if (!pwallet->LoadKey(key, vchPubKey))
src/wallet/walletdb.cpp:403:            if(pwallet->mapMasterKeys.count(nID) != 0)
src/wallet/walletdb.cpp:408:            pwallet->mapMasterKeys[nID] = kMasterKey;
src/wallet/walletdb.cpp:409:            if (pwallet->nMasterKeyMaxID < nID)
src/wallet/walletdb.cpp:410:                pwallet->nMasterKeyMaxID = nID;
src/wallet/walletdb.cpp:425:            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))
src/wallet/walletdb.cpp:439:            pwallet->LoadKeyMetadata(vchPubKey.GetID(), keyMeta);
src/wallet/walletdb.cpp:448:            pwallet->LoadScriptMetadata(CScriptID(script), keyMeta);
src/wallet/walletdb.cpp:468:            pwallet->LoadKeyPool(nIndex, keypool);
src/wallet/walletdb.cpp:482:            if (!pwallet->LoadCScript(script))
src/wallet/walletdb.cpp:490:            ssValue >> pwallet->nOrderPosNext;
src/wallet/walletdb.cpp:498:            pwallet->LoadDestData(DecodeDestination(strAddress), strKey, strValue);
src/wallet/walletdb.cpp:504:            pwallet->SetHDChain(chain, true);
src/wallet/walletdb.cpp:508:            if (!pwallet->SetWalletFlags(flags, true)) {
src/wallet/walletdb.cpp:534:    LOCK(pwallet->cs_wallet);
src/wallet/walletdb.cpp:541:            pwallet->LoadMinVersion(nMinVersion);
src/wallet/walletdb.cpp:548:            pwallet->WalletLogPrintf("Error getting wallet database cursor\n");
src/wallet/walletdb.cpp:562:                pwallet->WalletLogPrintf("Error reading next record from wallet database\n");
src/wallet/walletdb.cpp:586:                pwallet->WalletLogPrintf("%s\n", strErr);
src/wallet/walletdb.cpp:605:    pwallet->WalletLogPrintf("nFileVersion = %d\n", wss.nFileVersion);
src/wallet/walletdb.cpp:607:    pwallet->WalletLogPrintf("Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total. Unknown wallet records: %u\n",
src/wallet/walletdb.cpp:612:        pwallet->UpdateTimeFirstKey(1);
src/wallet/walletdb.cpp:615:        WriteTx(pwallet->mapWallet.at(hash));
src/wallet/walletdb.cpp:625:        result = pwallet->ReorderTransactions();
src/wallet/walletdb.cpp:627:    pwallet->laccentries.clear();
src/wallet/walletdb.cpp:628:    ListAccountCreditDebit("*", pwallet->laccentries);
src/wallet/walletdb.cpp:629:    for (CAccountingEntry& entry : pwallet->laccentries) {
src/wallet/walletdb.cpp:630:        pwallet->wtxOrdered.insert(make_pair(entry.nOrderPos, CWallet::TxPair(nullptr, &entry)));
src/wallet/walletdb.cpp:761:        WalletDatabase& dbh = pwallet->GetDBHandle();
src/wallet/rpcdump.cpp:72:    pwallet->GetKey(keyid, key);
src/wallet/rpcdump.cpp:74:        if (pwallet->mapAddressBook.count(dest)) {
src/wallet/rpcdump.cpp:79:            strLabel = EncodeDumpString(pwallet->mapAddressBook[dest].name);
src/wallet/rpcdump.cpp:84:        strAddr = EncodeDestination(GetDestinationForKey(key.GetPubKey(), pwallet->m_default_address_type));
src/wallet/rpcdump.cpp:137:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:164:            pwallet->MarkDirty();
src/wallet/rpcdump.cpp:167:                pwallet->SetAddressBook(dest, strLabel, "receive");
src/wallet/rpcdump.cpp:171:            if (pwallet->HaveKey(vchAddress)) {
src/wallet/rpcdump.cpp:176:            pwallet->UpdateTimeFirstKey(1);
src/wallet/rpcdump.cpp:177:            pwallet->mapKeyMetadata[vchAddress].nCreateTime = 1;
src/wallet/rpcdump.cpp:179:            if (!pwallet->AddKeyPubKey(key, pubkey)) {
src/wallet/rpcdump.cpp:182:            pwallet->LearnAllRelatedScripts(pubkey);
src/wallet/rpcdump.cpp:213:    if (!pwallet->IsScanning() || pwallet->IsAbortingRescan()) return false;
src/wallet/rpcdump.cpp:214:    pwallet->AbortRescan();
src/wallet/rpcdump.cpp:219:static void ImportScript(CWallet* const pwallet, const CScript& script, const std::string& strLabel, bool isRedeemScript) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)
src/wallet/rpcdump.cpp:225:    pwallet->MarkDirty();
src/wallet/rpcdump.cpp:227:    if (!pwallet->HaveWatchOnly(script) && !pwallet->AddWatchOnly(script, 0 /* nCreateTime */)) {
src/wallet/rpcdump.cpp:233:        if (!pwallet->HaveCScript(id) && !pwallet->AddCScript(script)) {
src/wallet/rpcdump.cpp:240:            pwallet->SetAddressBook(destination, strLabel, "receive");
src/wallet/rpcdump.cpp:245:static void ImportAddress(CWallet* const pwallet, const CTxDestination& dest, const std::string& strLabel) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)
src/wallet/rpcdump.cpp:251:        pwallet->SetAddressBook(dest, strLabel, "receive");
src/wallet/rpcdump.cpp:309:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:327:        pwallet->ReacceptWalletTransactions();
src/wallet/rpcdump.cpp:386:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:388:    if (pwallet->IsMine(*wtx.tx)) {
src/wallet/rpcdump.cpp:389:        pwallet->AddToWallet(wtx, false);
src/wallet/rpcdump.cpp:416:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:424:    if (pwallet->ZapSelectTx(vHash, vHashOut) != DBErrors::LOAD_OK) {
src/wallet/rpcdump.cpp:488:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:494:        pwallet->LearnAllRelatedScripts(pubKey);
src/wallet/rpcdump.cpp:499:        pwallet->ReacceptWalletTransactions();
src/wallet/rpcdump.cpp:540:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:556:        uiInterface.ShowProgress(strprintf("%s " + _("Importing..."), pwallet->GetDisplayName()), 0, false); // show progress dialog in GUI
src/wallet/rpcdump.cpp:573:                if (pwallet->HaveKey(keyid)) {
src/wallet/rpcdump.cpp:574:                    pwallet->WalletLogPrintf("Skipping import of %s (key already present)\n", EncodeDestination(keyid));
src/wallet/rpcdump.cpp:592:                pwallet->WalletLogPrintf("Importing %s...\n", EncodeDestination(keyid));
src/wallet/rpcdump.cpp:593:                if (!pwallet->AddKeyPubKey(key, pubkey)) {
src/wallet/rpcdump.cpp:597:                pwallet->mapKeyMetadata[keyid].nCreateTime = nTime;
src/wallet/rpcdump.cpp:599:                    pwallet->SetAddressBook(keyid, strLabel, "receive");
src/wallet/rpcdump.cpp:605:               if (pwallet->HaveCScript(id)) {
src/wallet/rpcdump.cpp:606:                   pwallet->WalletLogPrintf("Skipping import of %s (script already present)\n", vstr[0]);
src/wallet/rpcdump.cpp:609:               if(!pwallet->AddCScript(script)) {
src/wallet/rpcdump.cpp:610:                   pwallet->WalletLogPrintf("Error importing script %s\n", vstr[0]);
src/wallet/rpcdump.cpp:616:                   pwallet->m_script_metadata[id].nCreateTime = birth_time;
src/wallet/rpcdump.cpp:623:        pwallet->UpdateTimeFirstKey(nTimeBegin);
src/wallet/rpcdump.cpp:627:    pwallet->MarkDirty();
src/wallet/rpcdump.cpp:658:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:672:    if (!pwallet->GetKey(keyid, vchSecret)) {
src/wallet/rpcdump.cpp:705:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:727:    const std::map<CKeyID, int64_t>& mapKeyPool = pwallet->GetAllReserveKeys();
src/wallet/rpcdump.cpp:728:    pwallet->GetKeyBirthTimes(mapKeyBirth);
src/wallet/rpcdump.cpp:730:    std::set<CScriptID> scripts = pwallet->GetCScripts();
src/wallet/rpcdump.cpp:751:    CKeyID seed_id = pwallet->GetHDChain().seed_id;
src/wallet/rpcdump.cpp:755:        if (pwallet->GetKey(seed_id, seed)) {
src/wallet/rpcdump.cpp:768:        if (pwallet->GetKey(keyid, key)) {
src/wallet/rpcdump.cpp:776:            } else if (pwallet->mapKeyMetadata[keyid].hdKeypath == "s") {
src/wallet/rpcdump.cpp:781:            file << strprintf(" # addr=%s%s\n", strAddr, (pwallet->mapKeyMetadata[keyid].hdKeypath.size() > 0 ? " hdkeypath="+pwallet->mapKeyMetadata[keyid].hdKeypath : ""));
src/wallet/rpcdump.cpp:790:        auto it = pwallet->m_script_metadata.find(scriptid);
src/wallet/rpcdump.cpp:791:        if (it != pwallet->m_script_metadata.end()) {
src/wallet/rpcdump.cpp:794:        if(pwallet->GetCScript(scriptid, script)) {
src/wallet/rpcdump.cpp:810:static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)
src/wallet/rpcdump.cpp:892:            pwallet->MarkDirty();
src/wallet/rpcdump.cpp:894:            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {
src/wallet/rpcdump.cpp:899:            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {
src/wallet/rpcdump.cpp:909:            pwallet->MarkDirty();
src/wallet/rpcdump.cpp:911:            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {
src/wallet/rpcdump.cpp:917:                pwallet->SetAddressBook(dest, label, "receive");
src/wallet/rpcdump.cpp:935:                    pwallet->MarkDirty();
src/wallet/rpcdump.cpp:936:                    pwallet->SetAddressBook(vchAddress, label, "receive");
src/wallet/rpcdump.cpp:938:                    if (pwallet->HaveKey(vchAddress)) {
src/wallet/rpcdump.cpp:942:                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;
src/wallet/rpcdump.cpp:944:                    if (!pwallet->AddKeyPubKey(key, pubkey)) {
src/wallet/rpcdump.cpp:948:                    pwallet->UpdateTimeFirstKey(timestamp);
src/wallet/rpcdump.cpp:993:                pwallet->MarkDirty();
src/wallet/rpcdump.cpp:995:                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {
src/wallet/rpcdump.cpp:1001:                    pwallet->SetAddressBook(pubkey_dest, label, "receive");
src/wallet/rpcdump.cpp:1011:                pwallet->MarkDirty();
src/wallet/rpcdump.cpp:1013:                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {
src/wallet/rpcdump.cpp:1053:                pwallet->MarkDirty();
src/wallet/rpcdump.cpp:1054:                pwallet->SetAddressBook(vchAddress, label, "receive");
src/wallet/rpcdump.cpp:1056:                if (pwallet->HaveKey(vchAddress)) {
src/wallet/rpcdump.cpp:1060:                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;
src/wallet/rpcdump.cpp:1062:                if (!pwallet->AddKeyPubKey(key, pubKey)) {
src/wallet/rpcdump.cpp:1066:                pwallet->UpdateTimeFirstKey(timestamp);
src/wallet/rpcdump.cpp:1077:                pwallet->MarkDirty();
src/wallet/rpcdump.cpp:1079:                if (!pwallet->AddWatchOnly(script, timestamp)) {
src/wallet/rpcdump.cpp:1086:                        pwallet->SetAddressBook(dest, label, "receive");
src/wallet/rpcdump.cpp:1198:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcdump.cpp:1236:        int64_t scannedTime = pwallet->RescanFromTime(nLowestTimestamp, reserver, true /* update */);
src/wallet/rpcdump.cpp:1237:        pwallet->ReacceptWalletTransactions();
src/wallet/rpcdump.cpp:1239:        if (pwallet->IsAbortingRescan()) {
src/wallet/wallet.cpp:1637:        isminetype fIsMine = pwallet->IsMine(txout);
src/wallet/wallet.cpp:1644:            if (pwallet->IsChange(txout))
src/wallet/wallet.cpp:1655:            pwallet->WalletLogPrintf("CWalletTx::GetAmounts: Unknown transaction type found, txid %s\n",
src/wallet/wallet.cpp:1831:    assert(pwallet->GetBroadcastTransactions());
src/wallet/wallet.cpp:1837:            pwallet->WalletLogPrintf("Relaying wtx %s\n", GetHash().ToString());
src/wallet/wallet.cpp:1857:        result = pwallet->GetConflicts(myHash);
src/wallet/wallet.cpp:1875:            nDebitCached = pwallet->GetDebit(*tx, ISMINE_SPENDABLE);
src/wallet/wallet.cpp:1886:            nWatchDebitCached = pwallet->GetDebit(*tx, ISMINE_WATCH_ONLY);
src/wallet/wallet.cpp:1908:            nCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);
src/wallet/wallet.cpp:1919:            nWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);
src/wallet/wallet.cpp:1933:        nImmatureCreditCached = pwallet->GetCredit(*tx, ISMINE_SPENDABLE);
src/wallet/wallet.cpp:1969:        if (!pwallet->IsSpent(hashTx, i))
src/wallet/wallet.cpp:1972:            nCredit += pwallet->GetCredit(txout, filter);
src/wallet/wallet.cpp:1992:        nImmatureWatchCreditCached = pwallet->GetCredit(*tx, ISMINE_WATCH_ONLY);
src/wallet/wallet.cpp:2004:    nChangeCached = pwallet->GetChange(*tx);
src/wallet/wallet.cpp:2024:    if (!pwallet->m_spend_zero_conf_change || !IsFromMe(ISMINE_ALL)) // using wtx's cached debit
src/wallet/wallet.cpp:2035:        const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);
src/wallet/wallet.cpp:2039:        if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE)
src/wallet/wallet.cpp:3676:        if (!pwallet->ReserveKeyFromKeyPool(nIndex, keypool, internal)) {
src/wallet/wallet.cpp:3690:        pwallet->KeepKey(nIndex);
src/wallet/wallet.cpp:3698:        pwallet->ReturnKey(nIndex, fInternal, vchPubKey);
src/wallet/rpcwallet.cpp:68:    return pwallet && pwallet->IsCrypted()
src/wallet/rpcwallet.cpp:87:    if (pwallet->IsLocked()) {
src/wallet/rpcwallet.cpp:164:    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {
src/wallet/rpcwallet.cpp:168:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:175:    OutputType output_type = pwallet->m_default_address_type;
src/wallet/rpcwallet.cpp:182:    if (!pwallet->IsLocked()) {
src/wallet/rpcwallet.cpp:183:        pwallet->TopUpKeyPool();
src/wallet/rpcwallet.cpp:188:    if (!pwallet->GetKeyFromPool(newKey)) {
src/wallet/rpcwallet.cpp:191:    pwallet->LearnRelatedScripts(newKey, output_type);
src/wallet/rpcwallet.cpp:194:    pwallet->SetAddressBook(dest, label, "receive");
src/wallet/rpcwallet.cpp:202:    if (!pwallet->GetLabelDestination(dest, label, bForceNew)) {
src/wallet/rpcwallet.cpp:240:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:275:    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {
src/wallet/rpcwallet.cpp:279:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:281:    if (!pwallet->IsLocked()) {
src/wallet/rpcwallet.cpp:282:        pwallet->TopUpKeyPool();
src/wallet/rpcwallet.cpp:285:    OutputType output_type = pwallet->m_default_change_type != OutputType::CHANGE_AUTO ? pwallet->m_default_change_type : pwallet->m_default_address_type;
src/wallet/rpcwallet.cpp:299:    pwallet->LearnRelatedScripts(vchPubKey, output_type);
src/wallet/rpcwallet.cpp:334:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:341:    std::string old_label = pwallet->mapAddressBook[dest].name;
src/wallet/rpcwallet.cpp:345:        pwallet->SetAddressBook(dest, label, "receive");
src/wallet/rpcwallet.cpp:351:        pwallet->SetAddressBook(dest, label, "send");
src/wallet/rpcwallet.cpp:358:    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {
src/wallet/rpcwallet.cpp:365:        pwallet->DeleteLabel(old_label);
src/wallet/rpcwallet.cpp:401:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:409:    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(dest);
src/wallet/rpcwallet.cpp:410:    if (mi != pwallet->mapAddressBook.end() && !(*mi).second.name.empty()) {
src/wallet/rpcwallet.cpp:449:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:455:    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {
src/wallet/rpcwallet.cpp:467:    CAmount curBalance = pwallet->GetBalance();
src/wallet/rpcwallet.cpp:476:    if (pwallet->GetBroadcastTransactions() && !g_connman) {
src/wallet/rpcwallet.cpp:492:    if (!pwallet->CreateTransaction(vecSend, tx, reservekey, nFeeRequired, nChangePosRet, strError, coin_control)) {
src/wallet/rpcwallet.cpp:498:    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, std::move(fromAccount), reservekey, g_connman.get(), state)) {
src/wallet/rpcwallet.cpp:546:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:548:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:628:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:630:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:633:    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();
src/wallet/rpcwallet.cpp:634:    for (const std::set<CTxDestination>& grouping : pwallet->GetAddressGroupings()) {
src/wallet/rpcwallet.cpp:642:                if (pwallet->mapAddressBook.find(address) != pwallet->mapAddressBook.end()) {
src/wallet/rpcwallet.cpp:643:                    addressInfo.push_back(pwallet->mapAddressBook.find(address)->second.name);
src/wallet/rpcwallet.cpp:683:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:701:    if (!pwallet->GetKey(*keyID, key)) {
src/wallet/rpcwallet.cpp:747:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:749:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:768:    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {
src/wallet/rpcwallet.cpp:821:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:823:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:832:    std::set<CTxDestination> setAddress = pwallet->GetLabelAddresses(label);
src/wallet/rpcwallet.cpp:836:    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {
src/wallet/rpcwallet.cpp:912:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:914:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:940:            return ValueFromAmount(pwallet->GetLegacyBalance(filter, min_depth, account));
src/wallet/rpcwallet.cpp:944:    return ValueFromAmount(pwallet->GetBalance(filter, min_depth));
src/wallet/rpcwallet.cpp:963:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:965:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:967:    return ValueFromAmount(pwallet->GetUnconfirmedBalance());
src/wallet/rpcwallet.cpp:1008:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:1022:    if (!pwallet->AccountMove(strFrom, strTo, nAmount, strComment)) {
src/wallet/rpcwallet.cpp:1078:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:1080:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:1103:    CAmount nBalance = pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount);
src/wallet/rpcwallet.cpp:1209:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:1211:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:1213:    if (pwallet->GetBroadcastTransactions() && !g_connman) {
src/wallet/rpcwallet.cpp:1285:    if (IsDeprecatedRPCEnabled("accounts") && totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount)) {
src/wallet/rpcwallet.cpp:1287:    } else if (!IsDeprecatedRPCEnabled("accounts") && totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, nullptr)) {
src/wallet/rpcwallet.cpp:1300:    bool fCreated = pwallet->CreateTransaction(vecSend, tx, keyChange, nFeeRequired, nChangePosRet, strFailReason, coin_control);
src/wallet/rpcwallet.cpp:1304:    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, std::move(strAccount), keyChange, g_connman.get(), state)) {
src/wallet/rpcwallet.cpp:1353:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:1372:    OutputType output_type = pwallet->m_default_address_type;
src/wallet/rpcwallet.cpp:1382:    pwallet->SetAddressBook(dest, label, "send");
src/wallet/rpcwallet.cpp:1413:        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {
src/wallet/rpcwallet.cpp:1508:        pwallet->AddCScript(witprogram); // Implicit for single-key now, but necessary for multisig and for compatibility with older software
src/wallet/rpcwallet.cpp:1509:        pwallet->SetAddressBook(w.result, "", "receive");
src/wallet/rpcwallet.cpp:1558:    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {
src/wallet/rpcwallet.cpp:1597:    auto start = pwallet->mapAddressBook.begin();
src/wallet/rpcwallet.cpp:1598:    auto end = pwallet->mapAddressBook.end();
src/wallet/rpcwallet.cpp:1601:        start = pwallet->mapAddressBook.find(filtered_address);
src/wallet/rpcwallet.cpp:1719:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:1721:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:1771:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:1773:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:1821:            if (pwallet->mapAddressBook.count(s.destination)) {
src/wallet/rpcwallet.cpp:1822:                entry.pushKV("label", pwallet->mapAddressBook[s.destination].name);
src/wallet/rpcwallet.cpp:1839:            if (pwallet->mapAddressBook.count(r.destination)) {
src/wallet/rpcwallet.cpp:1840:                account = pwallet->mapAddressBook[r.destination].name;
src/wallet/rpcwallet.cpp:1864:                if (pwallet->mapAddressBook.count(r.destination)) {
src/wallet/rpcwallet.cpp:2010:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2038:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2040:        const CWallet::TxItems & txOrdered = pwallet->wtxOrdered;
src/wallet/rpcwallet.cpp:2124:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2126:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2137:    for (const std::pair<const CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {
src/wallet/rpcwallet.cpp:2143:    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {
src/wallet/rpcwallet.cpp:2159:                if (pwallet->mapAddressBook.count(r.destination)) {
src/wallet/rpcwallet.cpp:2160:                    mapAccountBalances[pwallet->mapAddressBook[r.destination].name] += r.amount;
src/wallet/rpcwallet.cpp:2167:    const std::list<CAccountingEntry>& acentries = pwallet->laccentries;
src/wallet/rpcwallet.cpp:2238:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2240:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2281:    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {
src/wallet/rpcwallet.cpp:2298:            auto it = pwallet->mapWallet.find(tx->GetHash());
src/wallet/rpcwallet.cpp:2299:            if (it != pwallet->mapWallet.end()) {
src/wallet/rpcwallet.cpp:2375:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2377:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2388:    auto it = pwallet->mapWallet.find(hash);
src/wallet/rpcwallet.cpp:2389:    if (it == pwallet->mapWallet.end()) {
src/wallet/rpcwallet.cpp:2443:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2445:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2450:    if (!pwallet->mapWallet.count(hash)) {
src/wallet/rpcwallet.cpp:2453:    if (!pwallet->AbandonTransaction(hash)) {
src/wallet/rpcwallet.cpp:2483:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2485:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2488:    if (!pwallet->BackupWallet(strDest)) {
src/wallet/rpcwallet.cpp:2517:    if (pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS)) {
src/wallet/rpcwallet.cpp:2521:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2532:    pwallet->TopUpKeyPool(kpSize);
src/wallet/rpcwallet.cpp:2534:    if (pwallet->GetKeyPoolSize() < kpSize) {
src/wallet/rpcwallet.cpp:2579:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2581:    if (!pwallet->IsCrypted()) {
src/wallet/rpcwallet.cpp:2606:        if (!pwallet->Unlock(strWalletPass)) {
src/wallet/rpcwallet.cpp:2615:    pwallet->TopUpKeyPool();
src/wallet/rpcwallet.cpp:2617:    pwallet->nRelockTime = GetTime() + nSleepTime;
src/wallet/rpcwallet.cpp:2618:    RPCRunLater(strprintf("lockwallet(%s)", pwallet->GetName()), std::bind(LockWallet, pwallet), nSleepTime);
src/wallet/rpcwallet.cpp:2646:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2648:    if (!pwallet->IsCrypted()) {
src/wallet/rpcwallet.cpp:2667:    if (!pwallet->ChangeWalletPassphrase(strOldWalletPass, strNewWalletPass)) {
src/wallet/rpcwallet.cpp:2702:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2704:    if (!pwallet->IsCrypted()) {
src/wallet/rpcwallet.cpp:2708:    pwallet->Lock();
src/wallet/rpcwallet.cpp:2709:    pwallet->nRelockTime = 0;
src/wallet/rpcwallet.cpp:2749:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2751:    if (pwallet->IsCrypted()) {
src/wallet/rpcwallet.cpp:2766:    if (!pwallet->EncryptWallet(strWalletPass)) {
src/wallet/rpcwallet.cpp:2825:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:2827:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2835:            pwallet->UnlockAllCoins();
src/wallet/rpcwallet.cpp:2869:        const auto it = pwallet->mapWallet.find(outpt.hash);
src/wallet/rpcwallet.cpp:2870:        if (it == pwallet->mapWallet.end()) {
src/wallet/rpcwallet.cpp:2880:        if (pwallet->IsSpent(outpt.hash, outpt.n)) {
src/wallet/rpcwallet.cpp:2884:        const bool is_locked = pwallet->IsLockedCoin(outpt.hash, outpt.n);
src/wallet/rpcwallet.cpp:2899:        if (fUnlock) pwallet->UnlockCoin(outpt);
src/wallet/rpcwallet.cpp:2900:        else pwallet->LockCoin(outpt);
src/wallet/rpcwallet.cpp:2941:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2944:    pwallet->ListLockedCoins(vOutpts);
src/wallet/rpcwallet.cpp:2982:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:2986:    pwallet->m_pay_tx_fee = CFeeRate(nAmount, 1000);
src/wallet/rpcwallet.cpp:3027:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:3029:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:3033:    size_t kpExternalSize = pwallet->KeypoolCountExternalKeys();
src/wallet/rpcwallet.cpp:3034:    obj.pushKV("walletname", pwallet->GetName());
src/wallet/rpcwallet.cpp:3035:    obj.pushKV("walletversion", pwallet->GetVersion());
src/wallet/rpcwallet.cpp:3036:    obj.pushKV("balance",       ValueFromAmount(pwallet->GetBalance()));
src/wallet/rpcwallet.cpp:3037:    obj.pushKV("unconfirmed_balance", ValueFromAmount(pwallet->GetUnconfirmedBalance()));
src/wallet/rpcwallet.cpp:3038:    obj.pushKV("immature_balance",    ValueFromAmount(pwallet->GetImmatureBalance()));
src/wallet/rpcwallet.cpp:3039:    obj.pushKV("txcount",       (int)pwallet->mapWallet.size());
src/wallet/rpcwallet.cpp:3040:    obj.pushKV("keypoololdest", pwallet->GetOldestKeyPoolTime());
src/wallet/rpcwallet.cpp:3042:    CKeyID seed_id = pwallet->GetHDChain().seed_id;
src/wallet/rpcwallet.cpp:3043:    if (!seed_id.IsNull() && pwallet->CanSupportFeature(FEATURE_HD_SPLIT)) {
src/wallet/rpcwallet.cpp:3044:        obj.pushKV("keypoolsize_hd_internal",   (int64_t)(pwallet->GetKeyPoolSize() - kpExternalSize));
src/wallet/rpcwallet.cpp:3046:    if (pwallet->IsCrypted()) {
src/wallet/rpcwallet.cpp:3047:        obj.pushKV("unlocked_until", pwallet->nRelockTime);
src/wallet/rpcwallet.cpp:3049:    obj.pushKV("paytxfee", ValueFromAmount(pwallet->m_pay_tx_fee.GetFeePerK()));
src/wallet/rpcwallet.cpp:3054:    obj.pushKV("private_keys_enabled", !pwallet->IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS));
src/wallet/rpcwallet.cpp:3267:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:3269:    if (!pwallet->GetBroadcastTransactions()) {
src/wallet/rpcwallet.cpp:3273:    std::vector<uint256> txids = pwallet->ResendWalletTransactionsBefore(GetTime(), g_connman.get());
src/wallet/rpcwallet.cpp:3400:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:3405:        LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:3406:        pwallet->AvailableCoins(vecOutputs, !include_unsafe, nullptr, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);
src/wallet/rpcwallet.cpp:3409:    LOCK(pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:3426:            auto i = pwallet->mapAddressBook.find(address);
src/wallet/rpcwallet.cpp:3427:            if (i != pwallet->mapAddressBook.end()) {
src/wallet/rpcwallet.cpp:3437:                if (pwallet->GetCScript(hash, redeemScript)) {
src/wallet/rpcwallet.cpp:3459:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:3506:            coinControl.m_change_type = pwallet->m_default_change_type;
src/wallet/rpcwallet.cpp:3566:    if (!pwallet->FundTransaction(tx, fee_out, change_position, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {
src/wallet/rpcwallet.cpp:3727:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:3829:    pwallet->BlockUntilSyncedToCurrentChain();
src/wallet/rpcwallet.cpp:3831:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:3914:    pwallet->GetScriptForMining(coinbase_script);
src/wallet/rpcwallet.cpp:3999:    CBlockIndex *stopBlock = pwallet->ScanForWalletTransactions(pindexStart, pindexStop, reserver, true);
src/wallet/rpcwallet.cpp:4001:        if (pwallet->IsAbortingRescan()) {
src/wallet/rpcwallet.cpp:4073:        if (pwallet && pwallet->GetPubKey(keyID, vchPubKey)) {
src/wallet/rpcwallet.cpp:4084:        if (pwallet && pwallet->GetCScript(scriptID, subscript)) {
src/wallet/rpcwallet.cpp:4094:        if (pwallet && pwallet->GetPubKey(CKeyID(id), pubkey)) {
src/wallet/rpcwallet.cpp:4107:        if (pwallet && pwallet->GetCScript(CScriptID(hash), subscript)) {
src/wallet/rpcwallet.cpp:4193:    LOCK(pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:4214:    if (pwallet->mapAddressBook.count(dest)) {
src/wallet/rpcwallet.cpp:4215:        ret.pushKV("label", pwallet->mapAddressBook[dest].name);
src/wallet/rpcwallet.cpp:4217:            ret.pushKV("account", pwallet->mapAddressBook[dest].name);
src/wallet/rpcwallet.cpp:4223:        auto it = pwallet->mapKeyMetadata.find(key_id);
src/wallet/rpcwallet.cpp:4224:        if (it != pwallet->mapKeyMetadata.end()) {
src/wallet/rpcwallet.cpp:4229:        auto it = pwallet->m_script_metadata.find(CScriptID(scriptPubKey));
src/wallet/rpcwallet.cpp:4230:        if (it != pwallet->m_script_metadata.end()) {
src/wallet/rpcwallet.cpp:4247:    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(dest);
src/wallet/rpcwallet.cpp:4248:    if (mi != pwallet->mapAddressBook.end()) {
src/wallet/rpcwallet.cpp:4282:    LOCK(pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:4288:    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {
src/wallet/rpcwallet.cpp:4332:    LOCK(pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:4341:    for (const std::pair<const CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {
src/wallet/rpcwallet.cpp:4390:    LOCK2(cs_main, pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:4393:    if (!pwallet->IsHDEnabled()) {
src/wallet/rpcwallet.cpp:4406:        master_pub_key = pwallet->GenerateNewSeed();
src/wallet/rpcwallet.cpp:4417:        master_pub_key = pwallet->DeriveNewSeed(key);
src/wallet/rpcwallet.cpp:4420:    pwallet->SetHDSeed(master_pub_key);
src/wallet/rpcwallet.cpp:4421:    if (flush_key_pool) pwallet->NewKeyPool();
src/wallet/rpcwallet.cpp:4470:    if (!pwallet->GetPubKey(keyID, vchPubKey)) {
src/wallet/rpcwallet.cpp:4474:    auto it = pwallet->mapKeyMetadata.find(keyID);
src/wallet/rpcwallet.cpp:4475:    if (it != pwallet->mapKeyMetadata.end()) {
src/wallet/rpcwallet.cpp:4485:        pwallet->GetKey(meta.hd_seed_id, key);
src/wallet/rpcwallet.cpp:4498:    LOCK(pwallet->cs_wallet);
src/wallet/rpcwallet.cpp:4507:        const auto it = pwallet->mapWallet.find(txhash);
src/wallet/rpcwallet.cpp:4508:        if (it != pwallet->mapWallet.end()) {
src/wallet/rpcwallet.cpp:4528:        if (it != pwallet->mapWallet.end()) {
